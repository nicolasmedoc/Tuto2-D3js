<!DOCTYPE html>
<div id="control-bar-container">
    <label>
        Nb rows
        <input name="nbRows" type="number"  onChange="handleOnChangeNbRows(this.value)"/>
    </label>

    <label>
        Nb columns
        <input name="nbCols" type="number" onChange="handleOnChangeNbCols(this.value)"/>
    </label>
    <button type="submit" onClick="handleOnClickGenerate()">Generate</button>
</div>

<div id="view-container"></div>

<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="text/javascript" src="./utils/helper.js"></script>
<script>
    // declaration of functions used in <div id="control-bar-container">
    let nbCols=8;
    let nbRows=8;
    let genData = genGridData(nbRows, nbCols);
    function handleOnClickGenerate(){
        genData = genGridData(nbRows,nbCols);
        removeMatrix();
        renderMatrix(genData);
    }
    function handleOnChangeNbRows(val){
        nbRows=val;
    }
    function handleOnChangeNbCols(val){
        nbCols=val;
    }

    function handleOnClickCell(cellData){
        const cellsToUpdate=[{...cellData, selected:!cellData.selected}]
        updateCellHighlighting(cellsToUpdate);
    }

    const viewSize = {width: 1400, height: 750};
    const margin = {top: 100, right: 5, bottom: 5, left: 100};
    let matSvg;
    let matSvgG;
    const cellSize = 30;
    const cellMargin = 5;

    // create the svg size by reducing the margin size
    const width = viewSize.width - margin.left - margin.right;
    const height = viewSize.height - margin.top - margin.bottom;

    // get the div with id="view-container"
    const viewContainer = d3.select("#view-container")
    matSvg = viewContainer.append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
    ;
    matSvgG = matSvg.append("g")
        .attr("class","matSvgG")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    ;
    
    function removeMatrix(){
        matSvgG.selectAll('*').remove();
    }

    function updateCellHighlighting(cellsToUpdate){
        matSvgG.selectAll(".cellG")
            .data(cellsToUpdate, cellData=>cellData.index)
            // no need to call join() because we don't need enter or exit
            // update selection is already returned by data()
            .select(".CellCircle")
            .attr("stroke-width",cellData=>{
                return cellData.selected?2:0
            });
        ;
    }


    function renderMatrix(genData) {
        // add d3 code here

        // build the size scale
        const radiusMin = 2;
        const radiusMax = cellSize / 2;
        const minNbProductSold = 0;
        // const minNbProductSold = d3.min(genData.map(cellData=>cellData.nbProductSold));
        const maxNbProductSold = d3.max(genData.map(cellData=>cellData.nbProductSold));
        const cellSizeScale = d3.scaleLinear()
            .domain([minNbProductSold, maxNbProductSold])
            .range([radiusMin, radiusMax-1])
        ;

        // build the color scale
        const colorScheme = d3.schemeRdYlBu[11];
        const cellColorScale = d3.scaleQuantile()
            .domain(genData.map(cellData=>cellData.salesGrowth))
            .range(colorScheme)
        ;

        function updateMatrix(update){
            // all data items matching with the previous data binding
            update.attr("transform",(cellData)=>{
                return "translate("+(cellData.colPos*cellSize)+","+(cellData.rowPos*cellSize)+")"
            });
            const circleSelection = update.select(".CellCircle")
                .attr("r",(cellData)=>cellSizeScale(cellData.nbProductSold))
                .attr("fill",(cellData) =>{
                    const color = cellColorScale(cellData.salesGrowth);
                    return color;
                })
                .attr("stroke-width", (cellData)=>cellData.selected?2:0);
            ;
        }

        const cellG = matSvgG.selectAll(".cellG")
            // selectAll returns all elements in the group matSvgG with the class .cellG (empty the first time)
            // bind the data with genData and indexes
            .data(genData,(cellData)=>cellData.index)
            .join(
              enter=>{
                  // all data items to add:
                  // didn't exist in the previous data binding but exist now in the new array
                  const cellG = enter.append("g")
                      .attr("class","cellG")
                      .on("click", (event,cellData)=>{
                          handleOnClickCell(cellData);
                      })
                  ;
                  // render circle as child of each element "g"
                  cellG.append("circle")
                      .attr("class","CellCircle")
                      .attr("cx",radiusMax)
                      .attr("cy",radiusMax)
                      .attr("stroke", "black")
                  ;
                  updateMatrix(cellG);
              },
              update=>{updateMatrix(update)},
              exit=>{
                  // all data items that don't exist anymore
                  exit.remove();
              }
            ); // end join()
    }

    renderMatrix(genData)

</script>