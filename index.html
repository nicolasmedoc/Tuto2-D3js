<!DOCTYPE html>
<div id="control-bar-container">
    <label>
        Nb rows
        <input name="nbRows" type="number"  onChange="handleOnChangeNbRows(this.value)"/>
    </label>

    <label>
        Nb columns
        <input name="nbCols" type="number" onChange="handleOnChangeNbCols(this.value)"/>
    </label>
    <button type="submit" onClick="handleOnClickGenerate()">Generate</button>
</div>

<div id="view-container"></div>

<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="text/javascript" src="./utils/helper.js"></script>
<script>
    // declaration of functions used in <div id="control-bar-container">
    let nbCols=8;
    let nbRows=8;
    let genData = genGridData(nbRows, nbCols);
    function handleOnClickGenerate(){
        genData = genGridData(nbRows,nbCols);
        removeMatrix();
        renderMatrix(genData);
    }
    function handleOnChangeNbRows(val){
        nbRows=val;
    }
    function handleOnChangeNbCols(val){
        nbCols=val;
    }

    const viewSize = {width: 1400, height: 750};
    const margin = {top: 100, right: 5, bottom: 5, left: 100};
    let matSvg;
    let matSvgG;
    const cellSize = 30;
    const cellMargin = 5;

    // create the svg size by reducing the margin size
    const width = viewSize.width - margin.left - margin.right;
    const height = viewSize.height - margin.top - margin.bottom;

    // get the div with id="view-container"
    const viewContainer = d3.select("#view-container")
    matSvg = viewContainer.append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
    ;
    matSvgG = matSvg.append("g")
        .attr("class","matSvgG")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    ;
    
    function removeMatrix(){
        matSvgG.selectAll('*').remove();
    }

    function renderMatrix(genData) {
        // add d3 code here

        // create the backgroud rectangle with the size of the grid
        matSvgG.append("rect")
            .attr("class","backgroundrect")
            .attr("width",(cellSize+cellMargin)*nbCols + cellMargin)
            .attr("height",(cellSize+cellMargin)*nbRows + cellMargin)
            .attr("fill","white")
        ;

        // build the size scale
        const radiusMin = 2;
        const radiusMax = cellSize / 2;
        const minNbProductSold = 0;
        // const minNbProductSold = d3.min(genData.map(cellData=>cellData.nbProductSold));
        const maxNbProductSold = d3.max(genData.map(cellData=>cellData.nbProductSold));
        const cellSizeScale = d3.scaleLinear()
            .domain([minNbProductSold, maxNbProductSold])
            .range([radiusMin, radiusMax-1])
        ;

        // build the color scale
        const colorScheme = d3.schemeRdYlBu[11];
        const cellColorScale = d3.scaleQuantile()
            .domain(genData.map(cellData=>cellData.salesGrowth))
            .range(colorScheme)
        ;

        const cellG = matSvgG.selectAll(".cellG")
            // selectAll returns all elements in the group matSvgG with the class .cellG (empty the first time)
            // bind the data with genData and indexes
            .data(genData,(cell)=>cell.index)
            .enter()
            // create groups <g> to add square in each cell of the grid
            .append("g")
            .attr("class","cellG")
            // apply translate transformation to define the right position of each cell
            .attr("transform",(cellG)=>{
                return "translate("+(cellG.colPos*(cellSize+cellMargin)+cellMargin)+","+(cellG.rowPos*(cellSize+cellMargin)+cellMargin)+")"
            })
        ;

        // render a circle as child of each element "g"
        cellG.append("circle")
            .attr("class","cellCircle")
            .attr("r", (cellData)=>{return cellSizeScale(cellData.nbProductSold)})
            .attr("cx", radiusMax)
            .attr("cy", radiusMax)
            .attr("fill", (cellData) =>{
                const color = cellColorScale(cellData.salesGrowth);
                return color;
            })
        ;

    }

    renderMatrix(genData)

</script>